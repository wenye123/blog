### 前言

在我们实际写业务过程中，可能会遇到一种需求，比如某个接口因为网络啥的原因不稳定 会报错，这时候我们就需要一种错误重试机制，比如失败我们就重试5次，5次还不行就算真的失败了，那这个功能具体需要怎么实现呢？

### 实现

接口本身是个promise，我们需要做的就是拦截promise的报错，在报错中加入重试机制。但是为了自定义的需求 我们可以将重试的控制权转移给调用者，以下是重试的主体代码。

```typescript
let retries = 0;
function load(ps: () => Promise<any>, onError?: (retry: Function, fail: Function, retries: number) => void) {
  // 拦截报错 将报错控制权交给onError回调
  return ps().catch((err) => {
    if (!onError) throw err;
    return new Promise((resolve, reject) => {
      // 重试函数
      const retry = () => {
        resolve(load(ps, onError));
        retries++;
      };
      // 失败函数
      const fail = () => {
        reject(err);
      };
      // 执行错误回调
      onError(retry, fail, retries);
    });
  });
}
```

在load方法中，如果接口本身响应正常就直接返回了，只有报错时候才能进入catch环节，这时候就需要记录重试次数，并将是否重试或者失败的控制权通过onError回调转移给使用者。

以下是一个实际的使用例子

```typescript
// 模拟请求接口网络不好 需要请求5次才能成功
let count = 0;
const api = () => {
  return new Promise((resolve, reject) => {
    if (count < 5) {
      reject("网络异常");
    } else {
      resolve("请求成功");
    }
    count++;
  });
};

// 调用接口 增加重试逻辑
load(api, (retry, fail, retries) => {
  // 小于指定次数则重试
  if (retries < 5) {
    console.info("重试次数", retries);
    retry()
  } else {
    console.error(`超过重试次数 按照失败处理`);
    fail();
  }
});
```

这里有一个需要注意地方，模拟请求接口是请求5次才能成功，意味着除了第1次请求，一共要重试4次才能成功。

因为控制权在调用者手里，所以这里你也可以改成延时1s后再重试都可以。

![示例](https://cdn.wenye123.com/pic/202308031114229.png)